#!/usr/bin/env node
/**
 * maZoneCEC Canvas Image Backup Utility - Functional Edition
 * A clean, functional approach to canvas-based book backup
 * 
 * @author DeltaGa & Robert56s
 * @version 4.0.0
 */

import { chromium } from 'playwright';
import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';
import { PDFDocument } from 'pdf-lib';
import readline from 'readline';
import './loadEnv.js';

// ============================================================================
// CONFIGURATION
// ============================================================================

const config = {
    auth: {
        username: process.env.USER,
        password: process.env.PASS,
        baseUrl: 'https://mazonecec.com/application/login',
    },
    selectors: {
        login: {
            username: 'xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[3]/div/div[1]/div[2]/div/div[1]/div[1]/div[1]/input',
            password: 'xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[3]/div/div[1]/div[2]/div/div[1]/div[1]/div[2]/input',
            rememberMe: 'xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[3]/div/div[1]/div[2]/div/div[1]/div[1]/button[1]',
            connectButton: 'xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[3]/div/div[1]/div[2]/div/div[1]/div[1]/button[2]',
        },
        navigation: {
            bookContainer: `xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[2]/div[2]/div/div/div/div/div/div[2]/div[2]/div`,
            bookTitle: (index) => `xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[2]/div[2]/div/div/div/div/div/div[2]/div[2]/div[${index}]/div/div/div[1]/div[2]/div/div/div/button/span`,
            openBook: (index) => `xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[2]/div[2]/div/div/div/div/div/div[2]/div[2]/div[${index}]/div/div/div[2]/div/div[2]/div/div[1]/div[1]/div/div[1]/button/img`,
            pageInput: `xpath=//*[@id="content"]/div/div/div/div/div[1]/div/div[1]/div[2]/div/div/div[3]/div[1]/input`,
            nextButton: 'xpath=//*[@id="DocumentContainer"]/div/div[3]/div[2]/div/button',
        },
        viewer: {
            canvas: '.canvasWrapper > canvas:nth-child(1)',
        },
    },
    timeouts: {
        navigation: 3000,
        canvasLoad: 6000,
        pageReload: 5000,
    },
    processing: {
        scaleFactor: 2.0,
        reloadInterval: 10,
    },
    paths: {
        tempDir: './imgs',
        saveDir: './save',
    },
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const ensureDirs = () => {
    [config.paths.tempDir, config.paths.saveDir].forEach(dir => {
        if (!fsSync.existsSync(dir)) {
            fsSync.mkdirSync(dir, { recursive: true });
        }
    });
};

const sanitizeFilename = (filename) =>
    filename
        .replace(/[<>:"/\\|?*]/g, '_')
        .replace(/\s+/g, '_')
        .substring(0, 200)
        .trim();

const askQuestion = (query) => {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    
    return new Promise(resolve => {
        rl.question(query, (answer) => {
            rl.close();
            resolve(answer);
        });
    });
};

// ============================================================================
// CANVAS PROCESSING ENGINE
// ============================================================================

/**
 * Advanced canvas processing with scaling capabilities
 */
class CanvasProcessor {
    constructor(scaleFactor = Config.PROCESSING.DEFAULT_SCALE_FACTOR) {
        this.scaleFactor = this.validateScaleFactor(scaleFactor);
        this.logger = console; // Could be replaced with proper logging framework
    }

    validateScaleFactor(factor) {
        const numericFactor = parseFloat(factor);
        
        if (isNaN(numericFactor) || numericFactor <= 0) {
            this.logger.warn(`Invalid scale factor ${factor}, using default ${Config.PROCESSING.DEFAULT_SCALE_FACTOR}`);
            return Config.PROCESSING.DEFAULT_SCALE_FACTOR;
        }

        if (numericFactor > Config.PROCESSING.MAX_SCALE_FACTOR) {
            this.logger.warn(`Scale factor ${factor} exceeds maximum, capping at ${Config.PROCESSING.MAX_SCALE_FACTOR}`);
            return Config.PROCESSING.MAX_SCALE_FACTOR;
        }

        if (numericFactor < Config.PROCESSING.MIN_SCALE_FACTOR) {
            this.logger.warn(`Scale factor ${factor} below minimum, setting to ${Config.PROCESSING.MIN_SCALE_FACTOR}`);
            return Config.PROCESSING.MIN_SCALE_FACTOR;
        }

        return numericFactor;
    }

    /**
     * Extract canvas data with optional scaling
     * @param {Page} page - Playwright page object
     * @returns {Promise<{base64: string, width: number, height: number}>}
     */
    async extractCanvasData(page) {
        return await TimingUtils.measure(async () => {
            return await page.evaluate((scaleFactor) => {
                const canvas = document.getElementsByTagName('canvas')[0];
                if (!canvas) {
                    throw new Error('No canvas element found on page');
                }

                // Get original dimensions
                const originalWidth = canvas.width;
                const originalHeight = canvas.height;
                
                // Calculate scaled dimensions
                const scaledWidth = Math.floor(originalWidth * scaleFactor);
                const scaledHeight = Math.floor(originalHeight * scaleFactor);

                // Create high-resolution canvas
                const scaledCanvas = document.createElement('canvas');
                scaledCanvas.width = scaledWidth;
                scaledCanvas.height = scaledHeight;
                
                const scaledCtx = scaledCanvas.getContext('2d');
                
                // Configure high-quality rendering
                scaledCtx.imageSmoothingEnabled = true;
                scaledCtx.imageSmoothingQuality = 'high';
                
                // Draw original canvas onto scaled canvas
                scaledCtx.drawImage(canvas, 0, 0, scaledWidth, scaledHeight);
                
                // Extract base64 data with optimal compression
                const base64Data = scaledCanvas.toDataURL('image/png', 0.95).split(';base64,')[1];
                
                return {
                    base64: base64Data,
                    width: scaledWidth,
                    height: scaledHeight,
                    originalWidth,
                    originalHeight,
                    scaleFactor,
                };
            }, this.scaleFactor);
        }, `Canvas extraction (${this.scaleFactor}x)`);
    }

    /**
     * Validate canvas availability and readiness
     */
    async waitForCanvas(page, timeout = Config.TIMEOUTS.canvasLoad) {
        try {
            await page.locator(Config.SELECTORS.viewer.canvas).waitFor({ timeout });
            
            // Additional validation - ensure canvas has content
            const hasContent = await page.evaluate(() => {
                const canvas = document.getElementsByTagName('canvas')[0];
                return canvas && canvas.width > 0 && canvas.height > 0;
            });

            if (!hasContent) {
                throw new Error('Canvas exists but appears empty');
            }

            await TimingUtils.timeout(Config.TIMEOUTS.canvasLoad);
            return true;
        } catch (error) {
            this.logger.error(`Canvas validation failed: ${error.message}`);
            return false;
        }
    }
}

// ============================================================================
// PLAYWRIGHT AUTOMATION ENGINE
// ============================================================================

/**
 * Professional Playwright automation with advanced error handling
 */
class PlaywrightAutomationEngine extends EventEmitter {
    constructor(options = {}) {
        super();
        this.browser = null;
        this.page = null;
        this.canvasProcessor = new CanvasProcessor(options.scaleFactor);
        this.performanceMonitor = new PerformanceMonitor();
        this.options = {
            headless: options.headless ?? false,
            slowMo: options.slowMo ?? 100,
            timeout: options.timeout ?? Config.TIMEOUTS.browserLaunch,
            ...options,
        };
    }

    /**
     * Initialize browser and page
     */
    async initialize() {
        try {
            this.browser = await chromium.launch({
                headless: this.options.headless,
                slowMo: this.options.slowMo,
                timeout: this.options.timeout,
            });

            this.page = await this.browser.newPage();
            
            // Configure page settings
            await this.page.setViewportSize({ width: 1920, height: 1080 });
            
            this.emit('initialized');
            return true;
        } catch (error) {
            this.emit('error', error);
            throw new Error(`Browser initialization failed: ${error.message}`);
        }
    }

    /**
     * Authenticate with the maZoneCEC platform
     */
    async authenticate() {
        try {
            await this.page.goto(Config.AUTH.BASE_URL);
            
            await this.page.locator(Config.SELECTORS.login.username).fill(Config.AUTH.USERNAME);
            await this.page.locator(Config.SELECTORS.login.password).fill(Config.AUTH.PASSWORD);
            await this.page.locator(Config.SELECTORS.login.rememberMe).click();
            await this.page.locator(Config.SELECTORS.login.connectButton).click();
            
            await this.page.waitForNavigation({ timeout: Config.TIMEOUTS.navigation });
            
            this.emit('authenticated');
            return true;
        } catch (error) {
            this.emit('error', error);
            throw new Error(`Authentication failed: ${error.message}`);
        }
    }

    /**
     * Discover and select book for processing
     */
    async discoverBook() {
        try {
            const bookName = await this.page.locator(Config.SELECTORS.navigation.bookTitle).innerText();
            
            await this.page.locator(Config.SELECTORS.navigation.openBook).click();
            await this.page.waitForNavigation({ timeout: Config.TIMEOUTS.navigation });
            
            // Navigate to cover page
            const pageInput = this.page.locator(Config.SELECTORS.navigation.pageInput);
            await pageInput.fill('C1');
            await pageInput.press('Enter');
            
            await TimingUtils.timeout(Config.TIMEOUTS.navigation);
            
            this.emit('bookSelected', { bookName });
            return bookName.trim();
        } catch (error) {
            this.emit('error', error);
            throw new Error(`Book discovery failed: ${error.message}`);
        }
    }

    /**
     * Process a single page with advanced error handling
     */
    async processPage(pageNumber) {
        try {
            // Wait for canvas to be ready
            const canvasReady = await this.canvasProcessor.waitForCanvas(this.page);
            if (!canvasReady) {
                throw new Error('Canvas not ready for processing');
            }

            // Extract canvas data with scaling
            const canvasData = await this.canvasProcessor.extractCanvasData(this.page);
            
            this.emit('pageProcessed', {
                pageNumber,
                dimensions: {
                    width: canvasData.width,
                    height: canvasData.height,
                    scaleFactor: canvasData.scaleFactor,
                },
            });

            return canvasData;
        } catch (error) {
            this.emit('pageError', { pageNumber, error });
            throw error;
        }
    }

    /**
     * Navigate to next page with intelligent error handling
     */
    async navigateToNextPage() {
        try {
            await this.page.locator(Config.SELECTORS.navigation.nextButton).click();
            await TimingUtils.timeout(Config.TIMEOUTS.imageProcessing);
            return true;
        } catch (error) {
            // End of book reached
            return false;
        }
    }

    /**
     * Perform intelligent page reload to manage memory
     */
    async performMaintenanceReload() {
        try {
            // Capture current page number
            var pageInput = this.page.locator(Config.SELECTORS.navigation.pageInput)
            const currentPage = await pageInput.inputValue();

            await this.page.reload({ timeout: Config.TIMEOUTS.pageReload });
            await TimingUtils.timeout(Config.TIMEOUTS.navigation);
            
            // Re-navigate to current position if needed
            pageInput = this.page.locator(Config.SELECTORS.navigation.pageInput);
            await pageInput.fill(currentPage);
            await pageInput.press('Enter');
            
            this.performanceMonitor.checkpoint('post-reload');
            this.emit('pageReloaded');
        } catch (error) {
            this.emit('reloadError', error);
            throw new Error(`Maintenance reload failed: ${error.message}`);
        }
    }

    /**
     * Cleanup resources
     */
    async cleanup() {
        try {
            if (this.page) {
                await this.page.close();
            }
            if (this.browser) {
                await this.browser.close();
            }
            this.emit('cleanup');
        } catch (error) {
            this.emit('error', error);
        }
    }
}

// ============================================================================
// FILE SYSTEM MANAGEMENT
// ============================================================================

/**
 * Professional file system operations with atomic guarantees
 */
class FileSystemManager {
    constructor() {
        this.ensureDirectories();
    }

    /**
     * Ensure required directories exist
     */
    ensureDirectories() {
        [Config.PATHS.TEMP_DIR, Config.PATHS.SAVE_DIR].forEach(dir => {
            if (!fsSync.existsSync(dir)) {
                fsSync.mkdirSync(dir, { recursive: true });
            }
        });
    }

    /**
     * Save image data with atomic write operations
     */
    async saveImage(pageNumber, base64Data) {
        const filename = `${pageNumber}.${Config.PATHS.OUTPUT_FORMAT}`;
        const filepath = path.join(Config.PATHS.TEMP_DIR, filename);
        
        try {
            await fs.writeFile(filepath, base64Data, 'base64');
            return filepath;
        } catch (error) {
            throw new Error(`Failed to save image ${filename}: ${error.message}`);
        }
    }

    /**
     * Create backup of processed images
     */
    async createBackup(bookName) {
        const sanitizedName = this.sanitizeFilename(bookName);
        const backupPath = path.join(Config.PATHS.SAVE_DIR, sanitizedName);
        
        try {
            // Ensure backup directory exists
            await fs.mkdir(backupPath, { recursive: true });
            
            // Copy all images to backup location
            const imageFiles = await fs.readdir(Config.PATHS.TEMP_DIR);
            
            for (const file of imageFiles) {
                const sourcePath = path.join(Config.PATHS.TEMP_DIR, file);
                const destPath = path.join(backupPath, file);
                await fs.copyFile(sourcePath, destPath);
            }
            
            return backupPath;
        } catch (error) {
            throw new Error(`Backup creation failed: ${error.message}`);
        }
    }

    /**
     * Clean up temporary files
     */
    async cleanup() {
        try {
            const files = await fs.readdir(Config.PATHS.TEMP_DIR);
            await Promise.all(
                files.map(file => 
                    fs.unlink(path.join(Config.PATHS.TEMP_DIR, file))
                )
            );
        } catch (error) {
            console.warn(`Cleanup warning: ${error.message}`);
        }
    }

    /**
     * Sanitize filename for cross-platform compatibility
     */
    sanitizeFilename(filename) {
        return filename
            .replace(/[<>:"/\\|?*]/g, '_')
            .replace(/\s+/g, '_')
            .substring(0, 200)
            .trim();
    }
}

// ============================================================================
// PDF GENERATION ENGINE
// ============================================================================

/**
 * High-performance PDF generation with memory optimization
 */
class PDFGenerator {
    constructor() {
        this.document = null;
    }

    /**
     * Initialize PDF document
     */
    async initialize() {
        this.document = await PDFDocument.create();
    }

    /**
     * Add page to PDF with optimized image handling
     */
    async addPage(base64Data, metadata = {}) {
        try {
            const page = this.document.addPage();
            const image = await this.document.embedPng(base64Data);
            
            // Calculate optimal dimensions while maintaining aspect ratio
            const { width: imgWidth, height: imgHeight } = image;
            const { width: pageWidth, height: pageHeight } = page.getSize();
            
            const scaleX = pageWidth / imgWidth;
            const scaleY = pageHeight / imgHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const drawWidth = imgWidth * scale;
            const drawHeight = imgHeight * scale;
            
            // Center the image on the page
            const x = (pageWidth - drawWidth) / 2;
            const y = (pageHeight - drawHeight) / 2;
            
            page.drawImage(image, {
                x,
                y,
                width: drawWidth,
                height: drawHeight,
            });
            
            return page;
        } catch (error) {
            throw new Error(`Failed to add page to PDF: ${error.message}`);
        }
    }

    /**
     * Finalize and save PDF
     */
    async finalize(filename) {
        try {
            const pdfBytes = await this.document.save();
            await fs.writeFile(filename, pdfBytes);
            return filename;
        } catch (error) {
            throw new Error(`PDF finalization failed: ${error.message}`);
        }
    }
}

// ============================================================================
// MAIN APPLICATION ORCHESTRATOR
// ============================================================================

/**
 * Professional application orchestrator with comprehensive error handling
 */
class maZoneCECCanvasBackupUtility extends EventEmitter {
    constructor(options = {}) {
        super();
        this.options = {
            scaleFactor: options.scaleFactor ?? Config.PROCESSING.DEFAULT_SCALE_FACTOR,
            headless: options.headless ?? false,
            generatePDF: options.generatePDF ?? true,
            ...options,
        };
        
        this.automation = new PlaywrightAutomationEngine({
            scaleFactor: this.options.scaleFactor,
            headless: this.options.headless,
        });
        
        this.fileManager = new FileSystemManager();
        this.pdfGenerator = new PDFGenerator();
        this.performanceMonitor = new PerformanceMonitor();
        
        this.setupEventHandlers();
        this.stats = {
            startTime: null,
            endTime: null,
            pagesProcessed: 0,
            errorsEncountered: 0,
            bookName: null,
        };
    }

    /**
     * Setup event handlers for comprehensive monitoring
     */
    setupEventHandlers() {
        this.automation.on('pageProcessed', (data) => {
            this.stats.pagesProcessed++;
            console.log(`üìÑ Page ${data.pageNumber} processed (${data.dimensions.width}x${data.dimensions.height} @ ${data.dimensions.scaleFactor}x)`);
        });

        this.automation.on('pageError', (data) => {
            this.stats.errorsEncountered++;
            console.error(`‚ùå Error on page ${data.pageNumber}: ${data.error.message}`);
        });

        this.automation.on('pageReloaded', () => {
            console.log('üîÑ Maintenance reload completed');
        });
    }

    /**
     * Execute the complete backup workflow
     */
    async run() {
        try {
            this.stats.startTime = performance.now();
            console.log('üé® maZoneCEC Canvas Backup Utility v3.0 - ES2023 Edition');
            console.log('=' .repeat(60));
            console.log(`üìè Scale Factor: ${this.options.scaleFactor}x`);
            console.log(`üñ•Ô∏è  Headless Mode: ${this.options.headless ? 'ON' : 'OFF'}`);
            console.log(`üìö PDF Generation: ${this.options.generatePDF ? 'ENABLED' : 'DISABLED'}`);
            console.log('=' .repeat(60));

            // Phase 1: Initialize automation
            console.log('üöÄ Initializing automation engine...');
            await this.automation.initialize();

            // Phase 2: Authentication
            console.log('üîê Authenticating...');
            await this.automation.authenticate();

            // Phase 3: Book discovery
            console.log('üìö Discovering book...');
            const bookName = await this.automation.discoverBook();
            this.stats.bookName = bookName;
            console.log(`üìñ Processing: "${bookName}"`);

            // Phase 4: PDF initialization
            if (this.options.generatePDF) {
                await this.pdfGenerator.initialize();
            }

            // Phase 5: Page processing loop
            console.log('‚ö° Starting page processing...');
            await this.processAllPages();

            // Phase 6: Finalization
            await this.finalizeOutput();

            this.stats.endTime = performance.now();
            this.printSummary();
            
            return true;

        } catch (error) {
            console.error(`üí• Critical error: ${error.message}`);
            return false;
        } finally {
            await this.cleanup();
        }
    }

    /**
     * Process all pages in the book
     */
    async processAllPages() {
        let pageNumber = 1;
        let hasNextPage = true;

        while (hasNextPage) {
            try {
                // Memory management - reload page periodically
                if (pageNumber > 1 && pageNumber % Config.PROCESSING.RELOAD_INTERVAL === 0) {
                    console.log('üßπ Performing maintenance reload...');
                    await this.automation.performMaintenanceReload();
                    this.performanceMonitor.logStats('Post-reload');
                }

                // Process current page
                const canvasData = await this.automation.processPage(pageNumber);
                
                // Save image
                await this.fileManager.saveImage(pageNumber, canvasData.base64);
                
                // Add to PDF if enabled
                if (this.options.generatePDF) {
                    await this.pdfGenerator.addPage(canvasData.base64, {
                        pageNumber,
                        scaleFactor: canvasData.scaleFactor,
                    });
                }

                // Navigate to next page
                hasNextPage = await this.automation.navigateToNextPage();
                pageNumber++;

            } catch (error) {
                console.error(`‚ö†Ô∏è  Page ${pageNumber} processing failed: ${error.message}`);
                this.stats.errorsEncountered++;
                
                // Try to continue with next page
                try {
                    hasNextPage = await this.automation.navigateToNextPage();
                    pageNumber++;
                } catch (navError) {
                    console.log('üìö End of book reached');
                    hasNextPage = false;
                }
            }
        }
    }

    /**
     * Finalize output generation
     */
    async finalizeOutput() {
        console.log('üèÅ Finalizing output...');

        // Generate PDF if enabled
        if (this.options.generatePDF && this.stats.pagesProcessed > 0) {
            const pdfFilename = `${this.fileManager.sanitizeFilename(this.stats.bookName)}.pdf`;
            await this.pdfGenerator.finalize(pdfFilename);
            console.log(`üìÑ PDF saved: ${pdfFilename}`);
        }

        // Create backup
        const backupPath = await this.fileManager.createBackup(this.stats.bookName);
        console.log(`üíæ Backup created: ${backupPath}`);
    }

    /**
     * Print processing summary
     */
    printSummary() {
        const duration = (this.stats.endTime - this.stats.startTime) / 1000;
        
        console.log('\n' + '=' .repeat(60));
        console.log('üìä PROCESSING SUMMARY');
        console.log('=' .repeat(60));
        console.log(`üìñ Book: ${this.stats.bookName}`);
        console.log(`üìÑ Pages Processed: ${this.stats.pagesProcessed}`);
        console.log(`‚ö†Ô∏è  Errors: ${this.stats.errorsEncountered}`);
        console.log(`üìè Scale Factor: ${this.options.scaleFactor}x`);
        console.log(`‚è±Ô∏è  Duration: ${duration.toFixed(2)} seconds`);
        console.log(`üìà Average: ${(this.stats.pagesProcessed / duration).toFixed(2)} pages/second`);
        this.performanceMonitor.logStats('Final');
        console.log('üéâ Processing completed successfully!');
        console.log('=' .repeat(60));
    }

    /**
     * Cleanup resources
     */
    async cleanup() {
        try {
            await this.automation.cleanup();
            await this.fileManager.cleanup();
        } catch (error) {
            console.warn(`Cleanup warning: ${error.message}`);
        }
    }
}

// ============================================================================
// CLI INTERFACE & APPLICATION ENTRY POINT
// ============================================================================

/**
 * Command-line interface with argument parsing
 */
class CLIInterface {
    static parseArguments() {
        const args = process.argv.slice(2);
        const options = {
            scaleFactor: Config.PROCESSING.DEFAULT_SCALE_FACTOR,
            headless: false,
            generatePDF: true,
        };

        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            
            switch (arg) {
                case '--scale':
                case '-s':
                    options.scaleFactor = parseFloat(args[++i]) || Config.PROCESSING.DEFAULT_SCALE_FACTOR;
                    break;
                case '--headless':
                case '-h':
                    options.headless = true;
                    break;
                case '--no-pdf':
                    options.generatePDF = false;
                    break;
                case '--help':
                    this.printHelp();
                    process.exit(0);
                    break;
            }
        }

        return options;
    }

    static printHelp() {
        console.log(`
üé® maZoneCEC Canvas Backup Utility v3.0 - ES2023 Edition
Professional canvas-based book backup with advanced scaling

USAGE:
    node backup-utility.js [OPTIONS]

OPTIONS:
    -s, --scale FACTOR      Set canvas scaling factor (1.0-4.0, default: 2.0)
                           Higher values produce higher resolution images
    
    -h, --headless         Run browser in headless mode (no GUI)
    
    --no-pdf              Skip PDF generation, save only individual images
    
    --help                Show this help message and exit

EXAMPLES:
    node backup-utility.js                   # Default 2x scaling with PDF
    node backup-utility.js -s 3.0            # 3x scaling for ultra-high resolution
    node backup-utility.js -h --scale 1.5    # Headless mode with 1.5x scaling
    node backup-utility.js --no-pdf -s 4.0   # Maximum scaling, images only

SCALING GUIDE:
    1.0x - Original canvas resolution
    2.0x - Double resolution (recommended for most use cases)
    3.0x - Triple resolution (high quality prints)
    4.0x - Maximum resolution (professional archival)

REQUIREMENTS:
    - Node.js 18+ with ES2023 support
    - Playwright browser automation
    - Valid credentials in environment variables
    - Sufficient disk space for high-resolution output

ENVIRONMENT VARIABLES:
    USER - maZoneCEC username
    PASS - maZoneCEC password
        `);
    }
}

/**
 * Professional error handling and graceful shutdown
 */
class ErrorHandler {
    static setupGlobalHandlers() {
        process.on('uncaughtException', (error) => {
            console.error('üí• Uncaught Exception:', error.message);
            console.error('Stack:', error.stack);
            process.exit(1);
        });

        process.on('unhandledRejection', (reason, promise) => {
            console.error('üí• Unhandled Rejection at:', promise);
            console.error('Reason:', reason);
            process.exit(1);
        });

        process.on('SIGINT', () => {
            console.log('\nüõë Received SIGINT, shutting down gracefully...');
            process.exit(0);
        });

        process.on('SIGTERM', () => {
            console.log('\nüõë Received SIGTERM, shutting down gracefully...');
            process.exit(0);
        });
    }

    static validateEnvironment() {
        const requiredVars = ['USER', 'PASS'];
        const missing = requiredVars.filter(varName => !process.env[varName]);
        
        if (missing.length > 0) {
            console.error('‚ùå Missing required environment variables:', missing.join(', '));
            console.error('Please set these variables in your .env file or environment');
            process.exit(1);
        }
    }
}

/**
 * Development and debugging utilities
 */
class DevUtils {
    /**
     * Memory usage tracking for development
     */
    static trackMemory(label = 'Memory Check') {
        const usage = process.memoryUsage();
        console.debug(`[${label}] Memory: ${Math.round(usage.heapUsed / 1024 / 1024)}MB heap, ${Math.round(usage.rss / 1024 / 1024)}MB RSS`);
    }

    /**
     * Performance benchmark wrapper
     */
    static async benchmark(operation, label = 'Operation') {
        const start = process.hrtime.bigint();
        const result = await operation();
        const end = process.hrtime.bigint();
        
        const duration = Number(end - start) / 1e6; // Convert to milliseconds
        console.debug(`[BENCHMARK] ${label}: ${duration.toFixed(2)}ms`);
        
        return result;
    }

    /**
     * Debug canvas information
     */
    static async debugCanvas(page) {
        const canvasInfo = await page.evaluate(() => {
            const canvas = document.getElementsByTagName('canvas')[0];
            if (!canvas) return null;
            
            return {
                width: canvas.width,
                height: canvas.height,
                clientWidth: canvas.clientWidth,
                clientHeight: canvas.clientHeight,
                style: {
                    width: canvas.style.width,
                    height: canvas.style.height,
                },
                hasContent: canvas.toDataURL().length > 1000, // Basic content check
            };
        });
        
        console.debug('[DEBUG] Canvas Info:', JSON.stringify(canvasInfo, null, 2));
        return canvasInfo;
    }
}

/**
 * Extended file system utilities for advanced operations
 */
class ExtendedFileSystemManager extends FileSystemManager {
    /**
     * Get detailed statistics about processed files
     */
    async getProcessingStats() {
        try {
            const files = await fs.readdir(Config.PATHS.TEMP_DIR);
            const imageFiles = files.filter(file => file.endsWith(`.${Config.PATHS.OUTPUT_FORMAT}`));
            
            let totalSize = 0;
            const fileStats = [];
            
            for (const file of imageFiles) {
                const filepath = path.join(Config.PATHS.TEMP_DIR, file);
                const stats = await fs.stat(filepath);
                totalSize += stats.size;
                
                fileStats.push({
                    filename: file,
                    size: stats.size,
                    created: stats.birthtime,
                });
            }
            
            return {
                fileCount: imageFiles.length,
                totalSize,
                averageSize: totalSize / imageFiles.length,
                files: fileStats.sort((a, b) => {
                    const aNum = parseInt(a.filename.split('.')[0]);
                    const bNum = parseInt(b.filename.split('.')[0]);
                    return aNum - bNum;
                }),
            };
        } catch (error) {
            console.warn(`Stats collection failed: ${error.message}`);
            return null;
        }
    }

    /**
     * Generate metadata file for the backup
     */
    async generateMetadata(bookName, processingStats, options) {
        const metadata = {
            book: {
                name: bookName,
                processedAt: new Date().toISOString(),
            },
            processing: {
                scaleFactor: options.scaleFactor,
                pagesProcessed: processingStats.pagesProcessed,
                errorsEncountered: processingStats.errorsEncountered,
                duration: processingStats.endTime - processingStats.startTime,
            },
            system: {
                nodeVersion: process.version,
                platform: process.platform,
                arch: process.arch,
                memory: process.memoryUsage(),
            },
            files: await this.getProcessingStats(),
        };

        const metadataPath = path.join(Config.PATHS.SAVE_DIR, this.sanitizeFilename(bookName), 'metadata.json');
        
        try {
            await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
            console.log(`üìã Metadata saved: ${metadataPath}`);
            return metadataPath;
        } catch (error) {
            console.warn(`Metadata generation failed: ${error.message}`);
        }
    }

    /**
     * Verify integrity of saved files
     */
    async verifyIntegrity() {
        try {
            const files = await fs.readdir(Config.PATHS.TEMP_DIR);
            const imageFiles = files.filter(file => file.endsWith(`.${Config.PATHS.OUTPUT_FORMAT}`));
            
            let corruptedFiles = 0;
            
            for (const file of imageFiles) {
                const filepath = path.join(Config.PATHS.TEMP_DIR, file);
                const stats = await fs.stat(filepath);
                
                // Basic integrity check - ensure file is not empty or suspiciously small
                if (stats.size < 1000) { // Less than 1KB is likely corrupted
                    console.warn(`‚ö†Ô∏è  Potentially corrupted file: ${file} (${stats.size} bytes)`);
                    corruptedFiles++;
                }
            }
            
            return {
                totalFiles: imageFiles.length,
                corruptedFiles,
                integrityScore: ((imageFiles.length - corruptedFiles) / imageFiles.length) * 100,
            };
        } catch (error) {
            console.warn(`Integrity verification failed: ${error.message}`);
            return null;
        }
    }
}

/**
 * Enhanced application orchestrator with extended features
 */
class EnhancedmaZoneCECBackupUtility extends maZoneCECCanvasBackupUtility {
    constructor(options = {}) {
        super(options);
        this.fileManager = new ExtendedFileSystemManager();
        this.isDevelopment = options.development ?? false;
    }

    /**
     * Enhanced finalization with metadata and verification
     */
    async finalizeOutput() {
        console.log('üèÅ Finalizing output with enhanced features...');

        // Generate PDF if enabled
        if (this.options.generatePDF && this.stats.pagesProcessed > 0) {
            const pdfFilename = `${this.fileManager.sanitizeFilename(this.stats.bookName)}.pdf`;
            await this.pdfGenerator.finalize(pdfFilename);
            console.log(`üìÑ PDF saved: ${pdfFilename}`);
        }

        // Verify file integrity
        const integrity = await this.fileManager.verifyIntegrity();
        if (integrity) {
            console.log(`üîç File integrity: ${integrity.integrityScore.toFixed(1)}% (${integrity.totalFiles - integrity.corruptedFiles}/${integrity.totalFiles} files)`);
        }

        // Create backup with enhanced features
        const backupPath = await this.fileManager.createBackup(this.stats.bookName);
        console.log(`üíæ Backup created: ${backupPath}`);

        // Generate metadata
        await this.fileManager.generateMetadata(this.stats.bookName, this.stats, this.options);

        // Development mode extras
        if (this.isDevelopment) {
            DevUtils.trackMemory('Final Memory Usage');
            const fileStats = await this.fileManager.getProcessingStats();
            if (fileStats) {
                console.log(`üìä Average file size: ${Math.round(fileStats.averageSize / 1024)}KB`);
                console.log(`üíø Total storage used: ${Math.round(fileStats.totalSize / 1024 / 1024)}MB`);
            }
        }
    }
}

/**
 * Application factory for creating configured instances
 */
class ApplicationFactory {
    static create(options = {}) {
        // Determine if we should use enhanced features
        const useEnhanced = options.development || options.enhanced || false;
        
        if (useEnhanced) {
            return new EnhancedmaZoneCECBackupUtility(options);
        } else {
            return new maZoneCECCanvasBackupUtility(options);
        }
    }

    static createFromCLI() {
        const options = CLIInterface.parseArguments();
        return this.create(options);
    }
}

// ============================================================================
// APPLICATION ENTRY POINT & MAIN EXECUTION
// ============================================================================

/**
 * Main application entry point
 */
async function main() {
    // Setup error handling
    ErrorHandler.setupGlobalHandlers();
    
    // Validate environment
    ErrorHandler.validateEnvironment();
    
    try {
        // Create and configure application
        const app = ApplicationFactory.createFromCLI();
        
        // Execute the backup process
        const success = await app.run();
        
        // Exit with appropriate code
        process.exit(success ? 0 : 1);
        
    } catch (error) {
        console.error('üí• Application failed to start:', error.message);
        if (process.env.NODE_ENV === 'development') {
            console.error('Stack trace:', error.stack);
        }
        process.exit(1);
    }
}

// ============================================================================
// ALTERNATIVE ENTRY POINTS FOR LIBRARY USAGE
// ============================================================================

/**
 * Library-style export for programmatic usage
 */
export {
    maZoneCECCanvasBackupUtility,
    EnhancedmaZoneCECBackupUtility,
    ApplicationFactory,
    Config,
    CanvasProcessor,
    PlaywrightAutomationEngine,
    FileSystemManager,
    ExtendedFileSystemManager,
    PDFGenerator,
    TimingUtils,
    PerformanceMonitor,
    DevUtils,
};

/**
 * Programmatic API for integration with other systems
 */
export async function createBackup(bookUrl, options = {}) {
    const app = ApplicationFactory.create({
        ...options,
        customUrl: bookUrl,
    });
    
    return await app.run();
}

/**
 * Batch processing API for multiple books
 */
export async function createBatchBackup(bookUrls, options = {}) {
    const results = [];
    
    for (const url of bookUrls) {
        try {
            const result = await createBackup(url, options);
            results.push({ url, success: result });
        } catch (error) {
            results.push({ url, success: false, error: error.message });
        }
    }
    
    return results;
}

// ============================================================================
// EXECUTION - Only run main() if this is the primary module
// ============================================================================

// if (import.meta.url === `file://${process.argv[1]}`) {
main().catch(error => {
    console.error('üí• Unhandled application error:', error);
    process.exit(1);
});
// }

// ============================================================================
// MODULE METADATA
// ============================================================================

export const VERSION = '3.0.0';
export const AUTHOR = 'DeltaGa & Robert56s';
export const DESCRIPTION = 'Professional maZoneCEC Canvas Backup Utility with Advanced Scaling';

console.log(`
üé® Module loaded: ${DESCRIPTION}
üì¶ Version: ${VERSION}
üë®‚Äçüíª Author: ${AUTHOR}
üöÄ ES2023 Features: Enabled
‚ö° Performance Mode: Optimized
`);
